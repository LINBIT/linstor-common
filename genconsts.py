#!/usr/bin/env python2

import datetime
import json
import os
import sys

langs = ['java', 'python', 'golang']
basename = os.path.basename(sys.argv[0])
script_path = os.path.dirname(os.path.abspath(__file__))
now = datetime.datetime.utcnow()
hdr = 'This file was autogenerated by %s' % (basename)
license = """
LINSTOR - management of distributed storage/DRBD9 resources
Copyright (C) 2017 - %s  LINBIT HA-Solutions GmbH
Author: %s

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.""" % (
    now.year, ', '.join(['Robert Altnoeder', 'Roland Kammerer', 'Gabor Hernadi']))


def java(consts):
    indent = ' ' * 4

    license_hdr = ''
    for l in license.split('\n'):
        license_hdr += (' * ' + l).rstrip() + '\n'

    print('/*\n * %s\n%s */\n' % (hdr, license_hdr))

    print('package com.linbit.linstor.api;\n')
    print('@SuppressWarnings({"checkstyle:magicnumber", "checkstyle:constantname"})')
    print('public class ApiConsts\n{')

    nl, w = '', 0
    for e in consts:
        w += 1
        if w > 1: nl = '\n'

        if 'blockcomment' in e:
            c = e['blockcomment'].replace('\n', '\n' + indent + ' * ')
            print('%s%s/*\n %s* %s\n %s*/' % (nl, indent, indent, c, indent))
            continue

        value = e['value']
        _type = e['type']
        native_type = None

        if _type == 'BOR':
            value = ' | '.join([str(x) for x in value])
            native_type = 'long'
        elif _type == 'BAND':
            value = ' & '.join([str(x) for x in value])
            native_type = 'long'
        elif _type == 'string':
            native_type = 'String'
            value = '"%s"' % value
        elif _type == 'bool':
            native_type = 'boolean'
        elif _type == 'int':
            native_type = 'int'
        elif _type == 'long':
            native_type = 'long'

        if native_type is None:
            raise RuntimeError("Type '{t}' not handled.".format(t=_type))

        if 'comment' in e:
            print("%s// %s" % (indent, e['comment']))
        c = "%spublic static final %s %s = %s;" % (indent, native_type, e['name'], value)
        print(c)

    print('\n    private ApiConsts()\n    {\n    }')
    print('}')


def strip_L(value):
    return value[:-1] if str(value).endswith('L') and str(value).startswith('0x') else value


def python(consts):
    print('# %s\n' % (hdr))
    print('# '.join([l.strip() + '\n' for l in license.split('\n')]))
    print("""import sys
if sys.version_info > (3,):
    long = int
""")

    store_mask = True
    masks = []
    nl, w = '', 0
    for e in consts:
        w += 1
        nl = '\n' if w > 1 else ''

        if 'blockcomment' in e:
            c = e['blockcomment'].replace('\n', '\n# ')
            if 'Special answer message content types' in c:
                store_mask = False
            print('%s# ## %s ###' % (nl, c))
            continue

        value = e['value']
        _type = e['type']

        if _type in ['long', 'BOR', 'BAND']:
            if isinstance(value, list):
                value = [strip_L(x) for x in value]
            else:
                value = strip_L(value)

        native_type = None

        if _type == 'BOR':
            value = ' | '.join([str(x) for x in value])
            native_type = 'long'
        elif _type == 'BAND':
            value = ' & '.join([str(x) for x in value])
            native_type = 'long'
        elif _type == 'string':
            native_type = 'str'
            value = "'%s'" % value
        elif _type == 'bool':
            native_type = 'bool'
        elif _type == 'int':
            native_type = 'int'
        elif _type == 'long':
            native_type = 'long'

        if store_mask:
            masks.append(e['name'])

        assert(native_type is not None)
        if 'comment' in e:
            print("# %s" % (e['comment']))
        c = "%s = %s(%s)" % (e['name'], native_type, value)
        print(c)

    print('\n\nif __name__ == "__main__":')
    print(' ' * 4 + 'MAP_MASK = {')
    print(',\n'.join([' ' * 8 + "'" + mask + "': " + mask for mask in masks]))
    print(' ' * 4 + '}')
    print("""    TYPE_MASKS = [
        0xC000000000000000,  # TYPE
        0x0000000003000000,  # OPERATION
        0x00000000003C0000,  # OBJECT
        0xC00000000000FFFF   # ACTION
    ]

    for num_str in sys.argv[1:]:
        num = long(num_str)
        mask = []
        for type_mask in TYPE_MASKS:
            for key, mask_value in MAP_MASK.items():
                if num & type_mask == mask_value:
                    mask.append(key)
        print(num_str + " = " + " | ". join(mask))""")


def golang(consts):
    print('// %s\n' % (hdr))
    print('// '.join([l.strip() + '\n' for l in license.split('\n')]))

    print('package linstor')

    store_mask = True
    masks = []
    nl, w = '', 0
    translated = {}

    for e in consts:
        w += 1
        nl = '\n' if w > 1 else ''

        if 'blockcomment' in e:
            c = e['blockcomment'].replace('\n', '\n// ')
            if 'Special answer message content types' in c:
                store_mask = False
            print('%s// ## %s ###' % (nl, c))
            continue

        value = e['value']
        _type = e['type']

        if _type in ['long', 'BOR', 'BAND']:
            if isinstance(value, list):
                value = [strip_L(x) for x in value]
            else:
                value = strip_L(value)

        if _type == 'BOR':
            value = [translated.get(v, v) for v in value]
            value = ' | '.join([str(x) for x in value])
            value = '(%s)' % value
        elif _type == 'BAND':
            value = [translated.get(v, v) for v in value]
            value = ' & '.join([str(x) for x in value])
            value = '(%s)' % value
        elif _type == 'string':
            value = '"%s"' % value

        if store_mask:
            masks.append(e['name'])

        if 'comment' in e:
            print("// %s" % (e['comment']))
        var = snake_to_camel(e['name'])
        translated[e['name']] = var
        c = "const %s = %s" % (var, value)
        print(c)


def snake_to_camel(name):
    return "".join(w.lower().title() for w in name.split("_"))


if len(sys.argv) < 2:
    sys.stderr.write("%s <language> [outfile]\n\tcurrently supported: %s\n" % (basename, ', '.join(langs)))
    sys.exit(1)
if len(sys.argv) == 3:
    sys.stdout = open(sys.argv[2], 'w')

language = sys.argv[1]
f = os.path.join(script_path, 'consts.json')
with open(f) as consts_file:
    try:
        consts = json.load(consts_file)
    except Exception as e:
        sys.stderr.write('The input file (%s) is not valid, better luck next time...\n' % (f))
        sys.stderr.write('Error: %s...\n' % (e))
        sys.exit(1)

    if language == 'java':
        java(consts)
    elif language == 'python':
        python(consts)
    elif language == 'golang':
        golang(consts)
    else:
        sys.stderr.write("Language '%s' not valid, valid languages are: %s\n" % (language, ','.join(langs)))
        sys.exit(1)
